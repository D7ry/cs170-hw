## Q2

Algorithm:
```python
k:int = problem.getK()
adjacency_list = problem.getAdjacencyList()
root = problem.getRoot()
s:dict[Node, int] = {}

def search(node, depth):
    """
    @arg node
        current node we're traversing
    @arg depth
        depth of the current node, root node has depth of 0
    @return 
        a dictionary, mapping depth (in int) to the number nodes that are of that distance to the root node.
    """
    ret = dict[int, int]()
    ret[depth] = 1 # record the node itself
    for child in adjacency_list[node]: # iterate over childs
        res = search(child, depth + 1) # depths of descendendents of one particular child

        # record the depths of descendents to this func's return value
        for child_depth in res:
            ret[child_depth] = 0 if child_depth not in ret
            ret[child_depth] += res[child_depth]

    # look at depths of all children, if the depth difference exceeds k between this node and the child, add the # of children.
    for child_depth in ret:
        if child_depth - depth >= k:
            s[node] += ret[child_depth]

    return ret

search(node=root, depth=0)
```